import * as vscode from "vscode";

let status: vscode.StatusBarItem;
let inlineEnabled = true;
let gatewayUrl = "http://127.0.0.1:3030";
let disposableProvider: vscode.Disposable | null = null;

const log = (...a: any[]) => console.log("[codexz]", ...a);
const cfgKey = "codexz";

async function health(): Promise<boolean> {
  try {
    const r = await fetch(`${gatewayUrl}/health`);
    return r.ok;
  } catch {
    return false;
  }
}

async function complete(doc: vscode.TextDocument, pos: vscode.Position) {
  const pre = doc.getText(
    new vscode.Range(new vscode.Position(Math.max(0, pos.line - 50), 0), pos)
  );
  const suf = doc.getText(
    new vscode.Range(
      pos,
      new vscode.Position(Math.min(doc.lineCount - 1, pos.line + 50), 1e6)
    )
  );
  const body = {
    language: doc.languageId,
    prefix: pre,
    suffix: suf,
    path: doc.uri.fsPath,
    cursor: { line: pos.line, ch: pos.character },
    budgetMs: 350
  };
  const r = await fetch(`${gatewayUrl}/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(`gateway ${r.status}`);
  return r.text();
}

function applyConfig() {
  const cfg = vscode.workspace.getConfiguration(cfgKey);
  gatewayUrl = String(cfg.get("gatewayUrl") ?? gatewayUrl);
  inlineEnabled = Boolean(cfg.get("inlineEnabled") ?? true);
  status.tooltip = `Gateway: ${gatewayUrl}`;
  log("config", { gatewayUrl, inlineEnabled });

  if (disposableProvider) {
    disposableProvider.dispose();
    disposableProvider = null;
  }

  if (inlineEnabled) {
    const provider: vscode.InlineCompletionItemProvider = {
      async provideInlineCompletionItems(doc, pos) {
        log("provider fired", doc.uri.fsPath, pos.line, pos.character);
        try {
          const text = await complete(doc, pos);
          if (!text) return;
          return { items: [{ insertText: text }] };
        } catch (e: any) {
          log("inline error", e?.message || e);
          status.text = "Codexz: FAILED";
          return;
        }
      }
    };
    disposableProvider = vscode.languages.registerInlineCompletionItemProvider(
      { pattern: "**/*" },
      provider
    );
  }
}

function nonce() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let s = "";
  for (let i = 0; i < 32; i++) s += chars.charAt(Math.floor(Math.random() * chars.length));
  return s;
}

function openChatPanel(_ctx: vscode.ExtensionContext) {
  // Keep the existing ID if you prefer; using a codexz-specific one for clarity.
  const panel = vscode.window.createWebviewPanel(
    "codexzChat",
    "Codexz Chat",
    vscode.ViewColumn.Beside,
    { enableScripts: true, retainContextWhenHidden: true }
  );

  const n = nonce();
  const csp =
    `default-src 'none'; ` +
    `style-src 'unsafe-inline'; ` +
    `img-src https: data:; ` +
    `script-src 'nonce-${n}'; ` +
    `connect-src http: https:;`;

  panel.webview.html = `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Content-Security-Policy" content="${csp}">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Codexz Chat</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 0; background: #0f111a; color: #e6e6e6; }
  #wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
  #hdr { padding: 8px 12px; border-bottom: 1px solid #2a2f45; color:#a0a8c0; font-size: 12px;}
  #msgs { padding: 12px; overflow-y: auto; }
  .msg { margin: 8px 0; padding: 10px 12px; border-radius: 10px; max-width: 80%; white-space: pre-wrap; }
  .user { background: #1b1e2b; margin-left: 20%; }
  .assistant { background: #13151f; border: 1px solid #2a2f45; margin-right: 20%; }
  #input { display:flex; gap:8px; padding: 10px; border-top: 1px solid #2a2f45; }
  #text { flex:1; resize: none; height: 60px; background:#0b0d16; color:#e6e6e6; border:1px solid #2a2f45; border-radius:8px; padding:8px; }
  button { background:#3b82f6; color:#fff; border:0; padding:8px 14px; border-radius:8px; cursor:pointer; }
  button:disabled { opacity: .6; cursor: wait; }
  select { background:#0b0d16; color:#e6e6e6; border:1px solid #2a2f45; border-radius:6px; padding:4px 6px; }
  .row { display:flex; gap:8px; align-items:center; margin-top:6px; }
</style>
</head>
<body>
<div id="wrap">
  <div id="hdr">
    <div>Gateway: <span id="gw"></span> • <span id="status">checking…</span></div>
    <div class="row">
  <label for="model" style="font-size:12px;color:#a0a8c0;">Model</label>
  <select id="model"></select>
  <button id="refresh" title="Refresh models" style="background:#2a2f45;color:#e6e6e6;">↻</button>
  <button id="load" title="Load model into RAM" style="background:#16a34a;color:#fff;">Load</button>
  <label style="margin-left:8px;display:flex;align-items:center;gap:6px;">
    <input type="checkbox" id="useCtx"> Use repo context
  </label>
  <button id="scan" title="Scan workspace" style="background:#2a2f45;color:#e6e6e6;">Scan</button>
  <button id="term" title="Open terminal" style="background:#2a2f45;color:#e6e6e6;">Terminal</button>
</div>

  </div>

  <div id="msgs"></div>

  <div id="input">
    <textarea id="text" placeholder="Type a message… Ctrl+Enter to send"></textarea>
    <button id="send">Send</button>
  </div>
</div>

<script nonce="${n}">
const vscodeApi = acquireVsCodeApi();
const GATEWAY = ${JSON.stringify(gatewayUrl)};
const msgsEl = document.getElementById('msgs');
const textEl = document.getElementById('text');
const sendBtn = document.getElementById('send');
const statusEl = document.getElementById('status');
const modelSel = document.getElementById('model');
const refreshBtn = document.getElementById('refresh');
document.getElementById('gw').textContent = GATEWAY;
const useCtxEl = document.getElementById('useCtx');
const scanBtn  = document.getElementById('scan');
const termBtn  = document.getElementById('term');
const loadBtn  = document.getElementById('load');

scanBtn.addEventListener('click', () => {
  statusEl.textContent = "scanning…";
  vscodeApi.postMessage({ type: "scan" });
});
termBtn.addEventListener('click', () => vscodeApi.postMessage({ type: "terminal" }));

window.addEventListener('message', (ev) => {
  const msg = ev.data || {};
  if (msg.type === "scanResult") {
    if (msg.ok) {
      push("assistant", `Indexed ${msg.data?.count ?? 0} files from ${msg.data?.root ?? ""}`);
      statusEl.textContent = "connected";
    } else {
      push("assistant", `⚠️ Scan failed: ${msg.error || "unknown error"}`);
      statusEl.textContent = "failed";
    }
  }
});

let messages = [];
let currentModel = localStorage.getItem('codexz:model') || "";

async function ping() {
  try {
    const r = await fetch(GATEWAY + "/health");
    statusEl.textContent = r.ok ? "connected" : "failed";
  } catch {
    statusEl.textContent = "failed";
  }
}

async function loadModels() {
  try {
    modelSel.innerHTML = "";
    const r = await fetch(GATEWAY + "/models");
    if (!r.ok) throw new Error("HTTP " + r.status);
    const data = await r.json();
    const names = (data && data.models) ? data.models : [];
    names.forEach((name) => {
      const o = document.createElement('option');
      o.value = name;
      o.textContent = name;
      modelSel.appendChild(o);
    });
    if (currentModel && names.includes(currentModel)) {
      modelSel.value = currentModel;
    } else if (names.length) {
      currentModel = names[0];
      modelSel.value = currentModel;
      localStorage.setItem('codexz:model', currentModel);
    }
    statusEl.textContent = (statusEl.textContent || "connected").replace(/(\\s•\\smodel:.*)?$/, " • model: " + (currentModel || "—"));
  } catch (e) {
    if (!modelSel.options.length) {
      const fallback = document.createElement('option');
      fallback.value = "";
      fallback.textContent = "(no models)";
      modelSel.appendChild(fallback);
    }
  }
}

modelSel.addEventListener('change', () => {
  currentModel = modelSel.value;
  localStorage.setItem('codexz:model', currentModel);
  statusEl.textContent = (statusEl.textContent || "connected").replace(/(\\s•\\smodel:.*)?$/, " • model: " + (currentModel || "—"));
});

refreshBtn.addEventListener('click', loadModels);

function push(role, content) {
  const el = document.createElement('div');
  el.className = 'msg ' + role;
  el.textContent = content;
  msgsEl.appendChild(el);
  msgsEl.scrollTop = msgsEl.scrollHeight;
}
function buildContextString(hits) {
  if (!hits || !hits.length) return "";
  let out = "";
  for (const h of hits) {
    for (const sn of (h.snippets || [])) {
      out += `\n=== ${h.path}:${sn.lineStart}-${sn.lineEnd} ===\n${sn.text}\n`;
      if (out.length > 12000) return out; // cap prompt bloat
    }
  }
  return out;
}

async function fetchContext(question) {
  try {
    const r = await fetch(GATEWAY + "/query", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ q: question, k: 6 })
    });
    if (!r.ok) return "";
    const data = await r.json().catch(() => ({}));
    return buildContextString(data?.hits || []);
  } catch { return ""; }
}

async function send() {
  const content = textEl.value.trim(); if (!content) return;
  textEl.value = ""; sendBtn.disabled = true;
  messages.push({ role:"user", content }); push("user", content);

  try {
    let messagesPayload = messages;
    if (useCtxEl.checked) {
      const ctx = await fetchContext(content);
      if (ctx) {
        messagesPayload = [
          { role: "system", content: "You are a coding assistant. Use ONLY the repository context below when answering. If context is insufficient, say so briefly.\n" + ctx },
          ...messages
        ];
      }
    }

    const r = await fetch(GATEWAY + "/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        messages: messagesPayload,
        model: currentModel || undefined,
        timeoutMs: 120000,
        keepAlive: "2h"
      })
    });
    if (!r.ok) throw new Error("HTTP " + r.status);
    const data = await r.json();
    const reply = data?.message?.content || "";
    messages.push({ role:"assistant", content: reply }); push("assistant", reply);
  } catch (e) {
    push("assistant", "⚠️ Error: " + (e.message || e));
  } finally {
    sendBtn.disabled = false; textEl.focus();
  }
}


sendBtn.addEventListener('click', send);
textEl.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) send();
});

// init
ping();
loadModels();
</script>
</body>
</html>`;
panel.webview.onDidReceiveMessage(async (msg) => {
  if (!msg || typeof msg !== "object") return;
  if (msg.type === "scan") {
    const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!root) { panel.webview.postMessage({ type: "scanResult", ok: false, error: "No workspace open" }); return; }
    try {
      const r = await fetch(`${gatewayUrl}/scan`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ root, maxFileSize: 262144 })
      });
      const data = await r.json().catch(() => ({}));
      panel.webview.postMessage({ type: "scanResult", ok: r.ok, data, error: r.ok ? undefined : (data?.error || "scan failed") });
    } catch (e:any) {
      panel.webview.postMessage({ type: "scanResult", ok: false, error: e?.message || String(e) });
    }
  } else if (msg.type === "terminal") {
    ensureTerminal().show();
  }
});

}
let codexzTerminal: vscode.Terminal | null = null;
function ensureTerminal(): vscode.Terminal {
  if (codexzTerminal && !codexzTerminal.exitStatus) return codexzTerminal;
  const cwd = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
  codexzTerminal = vscode.window.createTerminal({ name: "Codexz", cwd });
  return codexzTerminal;
}

export async function activate(ctx: vscode.ExtensionContext) {
  status = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 1000);
  status.text = "Codexz: …";
  status.command = "codexz.openChat"; // click to open chat
  status.show();
  ctx.subscriptions.push(status);

  applyConfig();
  status.text = (await health()) ? "Codexz: Connected" : "Codexz: FAILED";

  ctx.subscriptions.push(
    vscode.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(cfgKey)) applyConfig();
    })
  );

  ctx.subscriptions.push(
    vscode.commands.registerCommand("codexz.ping", async () => {
      status.text = "Codexz: …";
      status.text = (await health()) ? "Codexz: Connected" : "Codexz: FAILED";
    })
  );

  ctx.subscriptions.push(
    vscode.commands.registerCommand("codexz.test", async () => {
      const ed = vscode.window.activeTextEditor;
      if (!ed) return vscode.window.showWarningMessage("Open a file.");
      try {
        const out = await complete(ed.document, ed.selection.active);
        vscode.window.showInformationMessage(`Completion: ${out.slice(0, 120)}…`);
      } catch (e: any) {
        vscode.window.showErrorMessage(`Completion failed: ${e?.message || e}`);
      }
    })
  );

  ctx.subscriptions.push(
    vscode.commands.registerCommand("codexz.toggleInline", async () => {
      const cfg = vscode.workspace.getConfiguration(cfgKey);
      await cfg.update("inlineEnabled", !inlineEnabled, vscode.ConfigurationTarget.Global);
    })
  );

  ctx.subscriptions.push(
    vscode.commands.registerCommand("codexz.openChat", () => openChatPanel(ctx))
  );

  log("ready");
}

export function deactivate() {}
