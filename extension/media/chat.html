<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="{{CSP}}" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Codexz Chat</title>
    <style>
      body {
        font-family: 'Segoe UI', 'Fira Sans', 'system-ui', sans-serif;
        margin: 0;
        background: #181a20;
        color: #e6e6e6;
        letter-spacing: 0.01em;
      }
      #wrap {
        display: grid;
        grid-template-rows: auto 1fr auto;
        height: 100vh;
        max-width: 700px;
        margin: 0 auto;
        box-shadow: 0 2px 16px 0 #000a;
        border-radius: 14px;
        background: #1b1e24;
        border: 1px solid #23263a;
      }
      #hdr {
        padding: 14px 20px 8px 20px;
        border-bottom: 1px solid #23263a;
        color: #a0a8c0;
        font-size: 13px;
        background: #181a20;
        border-top-left-radius: 14px;
        border-top-right-radius: 14px;
      }
      #msgs {
        padding: 18px 20px;
        overflow-y: auto;
        background: #1b1e24;
      }
      .msg {
        margin: 12px 0;
        padding: 14px 18px;
        border-radius: 12px;
        max-width: 80%;
        white-space: pre-wrap;
        font-size: 15px;
        box-shadow: 0 1px 6px 0 #0002;
        transition: background 0.2s;
      }
      .user {
        background: linear-gradient(90deg, #23263a 60%, #1b1e2b 100%);
        margin-left: 20%;
        border: 1px solid #23263a;
      }
      .assistant {
        background: linear-gradient(90deg, #23263a 60%, #13151f 100%);
        border: 1px solid #23263a;
        margin-right: 20%;
      }
      #input {
        display: flex;
        gap: 10px;
        padding: 16px 20px;
        border-top: 1px solid #23263a;
        background: #181a20;
        border-bottom-left-radius: 14px;
        border-bottom-right-radius: 14px;
      }
      #text {
        flex: 1;
        resize: none;
        height: 56px;
        background: #23263a;
        color: #e6e6e6;
        border: 1px solid #2a2f45;
        border-radius: 8px;
        padding: 10px;
        font-size: 15px;
        box-shadow: 0 1px 4px 0 #0002;
        transition: border 0.2s;
      }
      #text:focus {
        border: 1.5px solid #3b82f6;
        outline: none;
      }
      button {
        background: linear-gradient(90deg, #3b82f6 80%, #2563eb 100%);
        color: #fff;
        border: none;
        padding: 10px 18px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        box-shadow: 0 1px 4px 0 #0002;
        transition:
          background 0.2s,
          box-shadow 0.2s;
      }
      button:disabled {
        opacity: 0.6;
        cursor: wait;
      }
      button#refresh,
      button#scan,
      button#term {
        background: #23263a;
        color: #e6e6e6;
        border: 1px solid #2a2f45;
        font-size: 14px;
        padding: 8px 12px;
        box-shadow: none;
      }
      button#load {
        background: linear-gradient(90deg, #16a34a 80%, #22c55e 100%);
        color: #fff;
        border: none;
        font-size: 14px;
        padding: 8px 14px;
      }
      select {
        background: #23263a;
        color: #e6e6e6;
        border: 1px solid #2a2f45;
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 14px;
        margin-right: 4px;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      label.inline {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 10px;
        font-size: 13px;
        color: #a0a8c0;
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <div id="hdr">
        <div>
          Gateway: <span id="gw"></span> • <span id="status">checking…</span>
        </div>
        <div class="row">
          <label for="model" style="font-size: 12px; color: #a0a8c0"
            >Model</label
          >
          <select id="model"></select>
          <button
            id="refresh"
            title="Refresh models"
            style="background: #2a2f45; color: #e6e6e6"
          >
            ↻
          </button>
          <button
            id="load"
            title="Load model into RAM"
            style="background: #16a34a; color: #fff"
          >
            Load
          </button>
          <label class="inline"
            ><input type="checkbox" id="useCtx" /> Use repo context</label
          >
          <button
            id="scan"
            title="Scan workspace"
            style="background: #2a2f45; color: #e6e6e6"
          >
            Scan
          </button>
          <button
            id="term"
            title="Open terminal"
            style="background: #2a2f45; color: #e6e6e6"
          >
            Terminal
          </button>
          <label class="inline"
            ><input type="checkbox" id="useStream" /> Use streaming</label
          >
        </div>
      </div>

      <div id="msgs"></div>

      <div id="input">
        <textarea
          id="text"
          placeholder="Type a message… Ctrl+Enter to send"
        ></textarea>
        <button id="send">Send</button>
      </div>
    </div>

    <script nonce="{{NONCE}}">
      const vscodeApi = acquireVsCodeApi();
      const DBG = (...a) => console.log('[codexz-webview]', ...a);
      const GATEWAY = '{{GATEWAY}}';

      const msgsEl = document.getElementById('msgs');
      const textEl = document.getElementById('text');
      const sendBtn = document.getElementById('send');
      const statusEl = document.getElementById('status');
      const modelSel = document.getElementById('model');
      const refreshBtn = document.getElementById('refresh');
      const loadBtn = document.getElementById('load');
      const useCtxEl = document.getElementById('useCtx');
      const scanBtn = document.getElementById('scan');
      const termBtn = document.getElementById('term');

      const useStreamEl = document.getElementById('useStream');

      document.getElementById('gw').textContent = GATEWAY;

      let messages = [];
      let currentModel = localStorage.getItem('codexz:model') || '';

      // ---------- helpers ----------
      function push(role, content) {
        const el = document.createElement('div');
        el.className = 'msg ' + role;
        el.textContent = content;
        msgsEl.appendChild(el);
        msgsEl.scrollTop = msgsEl.scrollHeight;
      }

      async function ping() {
        try {
          const r = await fetch(GATEWAY + '/health');
          statusEl.textContent = r.ok ? 'connected' : 'failed';
        } catch {
          statusEl.textContent = 'failed';
        }
      }

      async function loadModels() {
        try {
          modelSel.innerHTML = '';
          const r = await fetch(GATEWAY + '/models');
          if (!r.ok) throw new Error('HTTP ' + r.status);
          const data = await r.json();
          const names = data && data.models ? data.models : [];
          names.forEach((name) => {
            const o = document.createElement('option');
            o.value = name;
            o.textContent = name;
            modelSel.appendChild(o);
          });
          if (currentModel && names.includes(currentModel)) {
            modelSel.value = currentModel;
          } else if (names.length) {
            currentModel = names[0];
            modelSel.value = currentModel;
            localStorage.setItem('codexz:model', currentModel);
          }
          statusEl.textContent = (statusEl.textContent || 'connected').replace(
            /(\s•\smodel:.*)?$/,
            ` • model: ${currentModel || '—'}`
          );
        } catch {
          if (!modelSel.options.length) {
            const fallback = document.createElement('option');
            fallback.value = '';
            fallback.textContent = '(no models)';
            modelSel.appendChild(fallback);
          }
        }
      }

      modelSel.addEventListener('change', () => {
        currentModel = modelSel.value;
        localStorage.setItem('codexz:model', currentModel);
        statusEl.textContent = (statusEl.textContent || 'connected').replace(
          /(\s•\smodel:.*)?$/,
          ` • model: ${currentModel || '—'}`
        );
      });

      refreshBtn.addEventListener('click', loadModels);

      async function warmup() {
        if (!currentModel) return;
        loadBtn.disabled = true;
        const t0 = performance.now();
        statusEl.textContent = 'loading… (' + currentModel + ')';
        try {
          const r = await fetch(GATEWAY + '/warmup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: currentModel,
              keepAlive: '2h',
              timeoutMs: 300000,
            }),
          });
          const data = await r.json().catch(() => ({}));
          const ms = Math.round(performance.now() - t0);
          if (!r.ok || data?.ok === false)
            throw new Error((data && data.error) || 'HTTP ' + r.status);
          push(
            'assistant',
            `✓ Warmed '${currentModel}' in ${ms} ms${data.load_duration ? ` (loader ${data.load_duration}ns)` : ''}`
          );
        } catch (e) {
          push(
            'assistant',
            '⚠️ Warmup failed: ' + (e && e.message ? e.message : String(e))
          );
        } finally {
          loadBtn.disabled = false;
          statusEl.textContent = (statusEl.textContent || 'connected').replace(
            /(\s•\smodel:.*)?$/,
            ` • model: ${currentModel || '—'}`
          );
        }
      }
      loadBtn.addEventListener('click', warmup);

      // repo scan / terminal bridge
      scanBtn.addEventListener('click', () => {
        statusEl.textContent = 'scanning…';
        vscodeApi.postMessage({ type: 'scan' });
      });
      termBtn.addEventListener('click', () =>
        vscodeApi.postMessage({ type: 'terminal' })
      );

      window.addEventListener('message', (ev) => {
        const msg = ev.data || {};
        if (msg.type === 'scanResult') {
          if (msg.ok) {
            push(
              'assistant',
              `Indexed ${msg.data?.count ?? 0} files from ${msg.data?.root ?? ''}`
            );
            statusEl.textContent = 'connected';
          } else {
            push(
              'assistant',
              `⚠️ Scan failed: ${msg.error || 'unknown error'}`
            );
            statusEl.textContent = 'failed';
          }
        }
      });

      function buildContextString(hits) {
        if (!hits || !hits.length) return '';
        let out = '';
        for (const h of hits) {
          for (const sn of h.snippets || []) {
            out += `\n=== ${h.path}:${sn.lineStart}-${sn.lineEnd} ===\n${sn.text}\n`;
            if (out.length > 12000) return out;
          }
        }
        return out;
      }

      async function fetchContext(question) {
        try {
          const r = await fetch(GATEWAY + '/query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ q: question, k: 6 }),
          });
          if (!r.ok) return '';
          const data = await r.json().catch(() => ({}));
          return buildContextString(data?.hits || []);
        } catch {
          return '';
        }
      }

      // chat send
      async function send() {
        const content = textEl.value.trim();
        if (!content) return;
        textEl.value = '';
        sendBtn.disabled = true;
        messages.push({ role: 'user', content });
        push('user', content);

        try {
          let messagesPayload = messages;
          if (useCtxEl.checked) {
            const ctx = await fetchContext(content);
            if (ctx) {
              messagesPayload = [
                {
                  role: 'system',
                  content:
                    'You are a coding assistant. Use ONLY the repository context below when answering. If context is insufficient, say so briefly.\n' +
                    ctx,
                },
                ...messages,
              ];
            }
          }

          if (useStreamEl.checked) {
            const r = await fetch(GATEWAY + '/chat/stream', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                messages: messagesPayload,
                model: currentModel || undefined,
                timeoutMs: 120000,
                keepAlive: '2h',
              }),
            });
            if (!r.ok) throw new Error('HTTP ' + r.status);
            const reader = r.body.getReader();
            const decoder = new TextDecoder();
            let fullReply = '';
            const el = push('assistant', '');

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n');
              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  const json = JSON.parse(line.slice(6));
                  if (json.done) break;
                  const content = json?.message?.content || '';
                  fullReply += content;
                  el.textContent = fullReply;
                  msgsEl.scrollTop = msgsEl.scrollHeight;
                }
              }
            }
            messages.push({ role: 'assistant', content: fullReply });
            pushAssistantRich(fullReply);
          } else {
            const r = await fetch(GATEWAY + '/chat', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                messages: messagesPayload,
                model: currentModel || undefined,
                timeoutMs: 120000,
                keepAlive: '2h',
              }),
            });
            if (!r.ok) throw new Error('HTTP ' + r.status);
            const data = await r.json();
            const reply = data?.message?.content || '';
            messages.push({ role: 'assistant', content: reply });
            pushAssistantRich(reply);
          }
        } catch (e) {
          push('assistant', '⚠️ Error: ' + (e.message || e));
        } finally {
          sendBtn.disabled = false;
          textEl.focus();
        }
      }

      sendBtn.addEventListener('click', send);
      textEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) send();
      });
      function extractShellBlocks(text) {
        const blocks = [];
        const regex = /```(?:bash|sh)?\n([\s\S]*?)```/g;
        let m;
        while ((m = regex.exec(text))) blocks.push(m[1].trim());
        return blocks;
      }

      function pushAssistantRich(content) {
        // For each bash block, render a runnable block
        const blocks = extractShellBlocks(content);
        if (blocks.length > 0) {
          for (const code of blocks) {
            const wrap = document.createElement('div');
            wrap.className = 'msg assistant';
            const pre = document.createElement('pre');
            pre.style.margin = '8px 0';
            pre.style.whiteSpace = 'pre-wrap';
            pre.textContent = code;

            const run = document.createElement('button');
            run.textContent = 'Run in terminal';
            run.style.marginTop = '6px';
            run.style.background = '#2a2f45';
            run.style.color = '#e6e6e6';
            run.addEventListener('click', () => {
              const ok = confirm(
                'Run these commands in your workspace terminal?\n\n' + code
              );
              if (!ok) return;
              vscodeApi.postMessage({ type: 'runShell', code });
            });

            wrap.appendChild(pre);
            wrap.appendChild(run);
            msgsEl.appendChild(wrap);
            msgsEl.scrollTop = msgsEl.scrollHeight;
          }
        }
      }
      // init
      ping();
      loadModels();
    </script>
  </body>
</html>
