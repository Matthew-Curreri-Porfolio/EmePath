<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Content-Security-Policy" content="{{CSP}}" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Codexz Chat</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 0; background: #0f111a; color: #e6e6e6; }
  #wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
  #hdr { padding: 8px 12px; border-bottom: 1px solid #2a2f45; color:#a0a8c0; font-size:12px; }
  #msgs { padding: 12px; overflow-y: auto; }
  .msg { margin: 8px 0; padding: 10px 12px; border-radius: 10px; max-width: 80%; white-space: pre-wrap; }
  .user { background: #1b1e2b; margin-left: 20%; }
  .assistant { background: #13151f; border: 1px solid #2a2f45; margin-right: 20%; }
  #input { display:flex; gap:8px; padding: 10px; border-top: 1px solid #2a2f45; }
  #text { flex:1; resize:none; height:60px; background:#0b0d16; color:#e6e6e6; border:1px solid #2a2f45; border-radius:8px; padding:8px; }
  button { background:#3b82f6; color:#fff; border:0; padding:8px 14px; border-radius:8px; cursor:pointer; }
  button:disabled { opacity:.6; cursor:wait; }
  select { background:#0b0d16; color:#e6e6e6; border:1px solid #2a2f45; border-radius:6px; padding:4px 6px; }
  .row { display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap: wrap; }
  label.inline { display:flex; align-items:center; gap:6px; margin-left:8px; }
</style>
</head>
<body>
<div id="wrap">
  <div id="hdr">
    <div>Gateway: <span id="gw"></span> • <span id="status">checking…</span></div>
    <div class="row">
      <label for="model" style="font-size:12px;color:#a0a8c0;">Model</label>
      <select id="model"></select>
      <button id="refresh" title="Refresh models" style="background:#2a2f45;color:#e6e6e6;">↻</button>
      <button id="load" title="Load model into RAM" style="background:#16a34a;color:#fff;">Load</button>
      <label class="inline"><input type="checkbox" id="useCtx" /> Use repo context</label>
      <button id="scan" title="Scan workspace" style="background:#2a2f45;color:#e6e6e6;">Scan</button>
      <button id="term" title="Open terminal" style="background:#2a2f45;color:#e6e6e6;">Terminal</button>
    </div>
  </div>

  <div id="msgs"></div>

  <div id="input">
    <textarea id="text" placeholder="Type a message… Ctrl+Enter to send"></textarea>
    <button id="send">Send</button>
  </div>
</div>

<script nonce="{{NONCE}}">
const vscodeApi = acquireVsCodeApi();
const DBG = (...a) => console.log("[codexz-webview]", ...a);
const GATEWAY = "{{GATEWAY}}";

const msgsEl = document.getElementById('msgs');
const textEl = document.getElementById('text');
const sendBtn = document.getElementById('send');
const statusEl = document.getElementById('status');
const modelSel = document.getElementById('model');
const refreshBtn = document.getElementById('refresh');
const loadBtn = document.getElementById('load');
const useCtxEl = document.getElementById('useCtx');
const scanBtn  = document.getElementById('scan');
const termBtn  = document.getElementById('term');

document.getElementById('gw').textContent = GATEWAY;

let messages = [];
let currentModel = localStorage.getItem('codexz:model') || "";

// ---------- helpers ----------
function push(role, content) {
  const el = document.createElement('div');
  el.className = 'msg ' + role;
  el.textContent = content;
  msgsEl.appendChild(el);
  msgsEl.scrollTop = msgsEl.scrollHeight;
}

async function ping() {
  try {
    const r = await fetch(GATEWAY + "/health");
    statusEl.textContent = r.ok ? "connected" : "failed";
  } catch {
    statusEl.textContent = "failed";
  }
}

async function loadModels() {
  try {
    modelSel.innerHTML = "";
    const r = await fetch(GATEWAY + "/models");
    if (!r.ok) throw new Error("HTTP " + r.status);
    const data = await r.json();
    const names = (data && data.models) ? data.models : [];
    names.forEach((name) => {
      const o = document.createElement('option');
      o.value = name; o.textContent = name;
      modelSel.appendChild(o);
    });
    if (currentModel && names.includes(currentModel)) {
      modelSel.value = currentModel;
    } else if (names.length) {
      currentModel = names[0];
      modelSel.value = currentModel;
      localStorage.setItem('codexz:model', currentModel);
    }
    statusEl.textContent = (statusEl.textContent || "connected").replace(/(\s•\smodel:.*)?$/, ` • model: ${currentModel || "—"}`);
  } catch {
    if (!modelSel.options.length) {
      const fallback = document.createElement('option');
      fallback.value = ""; fallback.textContent = "(no models)";
      modelSel.appendChild(fallback);
    }
  }
}

modelSel.addEventListener('change', () => {
  currentModel = modelSel.value;
  localStorage.setItem('codexz:model', currentModel);
  statusEl.textContent = (statusEl.textContent || "connected").replace(/(\s•\smodel:.*)?$/, ` • model: ${currentModel || "—"}`);
});

refreshBtn.addEventListener('click', loadModels);

async function warmup() {
  if (!currentModel) return;
  loadBtn.disabled = true;
  const t0 = performance.now();
  statusEl.textContent = "loading… (" + currentModel + ")";
  try {
    const r = await fetch(GATEWAY + "/warmup", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: currentModel, keepAlive: "2h", timeoutMs: 300000 })
    });
    const data = await r.json().catch(() => ({}));
    const ms = Math.round(performance.now() - t0);
    if (!r.ok || data?.ok === false) throw new Error((data && data.error) || ("HTTP " + r.status));
    push("assistant", `✓ Warmed '${currentModel}' in ${ms} ms${data.load_duration ? ` (loader ${data.load_duration}ns)` : ""}`);
  } catch (e) {
    push("assistant", "⚠️ Warmup failed: " + (e && e.message ? e.message : String(e)));
  } finally {
    loadBtn.disabled = false;
    statusEl.textContent = (statusEl.textContent || "connected").replace(/(\s•\smodel:.*)?$/, ` • model: ${currentModel || "—"}`);
  }
}
loadBtn.addEventListener('click', warmup);

// repo scan / terminal bridge
scanBtn.addEventListener('click', () => {
  statusEl.textContent = "scanning…";
  vscodeApi.postMessage({ type: "scan" });
});
termBtn.addEventListener('click', () => vscodeApi.postMessage({ type: "terminal" }));

window.addEventListener('message', (ev) => {
  const msg = ev.data || {};
  if (msg.type === "scanResult") {
    if (msg.ok) {
      push("assistant", `Indexed ${msg.data?.count ?? 0} files from ${msg.data?.root ?? ""}`);
      statusEl.textContent = "connected";
    } else {
      push("assistant", `⚠️ Scan failed: ${msg.error || "unknown error"}`);
      statusEl.textContent = "failed";
    }
  }
});

function buildContextString(hits) {
  if (!hits || !hits.length) return "";
  let out = "";
  for (const h of hits) {
    for (const sn of (h.snippets || [])) {
      out += `\n=== ${h.path}:${sn.lineStart}-${sn.lineEnd} ===\n${sn.text}\n`;
      if (out.length > 12000) return out;
    }
  }
  return out;
}

async function fetchContext(question) {
  try {
    const r = await fetch(GATEWAY + "/query", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ q: question, k: 6 })
    });
    if (!r.ok) return "";
    const data = await r.json().catch(() => ({}));
    return buildContextString(data?.hits || []);
  } catch { return ""; }
}

// chat send
async function send() {
  const content = textEl.value.trim(); if (!content) return;
  textEl.value = ""; sendBtn.disabled = true;
  messages.push({ role:"user", content }); push("user", content);

  try {
    let messagesPayload = messages;
    if (useCtxEl.checked) {
      const ctx = await fetchContext(content);
      if (ctx) {
        messagesPayload = [
          { role: "system", content: "You are a coding assistant. Use ONLY the repository context below when answering. If context is insufficient, say so briefly.\n" + ctx },
          ...messages
        ];
      }
    }

    const r = await fetch(GATEWAY + "/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        messages: messagesPayload,
        model: currentModel || undefined,
        timeoutMs: 120000,
        keepAlive: "2h"
      })
    });
    if (!r.ok) throw new Error("HTTP " + r.status);
    const data = await r.json();
    const reply = data?.message?.content || "";
    messages.push({ role:"assistant", content: reply });
pushAssistantRich(reply);
  } catch (e) {
    push("assistant", "⚠️ Error: " + (e.message || e));
  } finally {
    sendBtn.disabled = false; textEl.focus();
  }
}

sendBtn.addEventListener('click', send);
textEl.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) send();
});
function extractShellBlocks(text) {
  const blocks = [];
  const regex = /```(?:bash|sh)?\n([\s\S]*?)```/g;
  let m; while ((m = regex.exec(text))) blocks.push(m[1].trim());
  return blocks;
}

function pushAssistantRich(content) {
  // Plain text bubble
  push("assistant", content);

  // For each bash block, render a runnable block
  const blocks = extractShellBlocks(content);
  for (const code of blocks) {
    const wrap = document.createElement('div');
    wrap.className = 'msg assistant';
    const pre = document.createElement('pre');
    pre.style.margin = '8px 0';
    pre.style.whiteSpace = 'pre-wrap';
    pre.textContent = code;

    const run = document.createElement('button');
    run.textContent = 'Run in terminal';
    run.style.marginTop = '6px';
    run.style.background = '#2a2f45';
    run.style.color = '#e6e6e6';
    run.addEventListener('click', () => {
      const ok = confirm('Run these commands in your workspace terminal?\n\n' + code);
      if (!ok) return;
      vscodeApi.postMessage({ type: 'runShell', code });
    });

    wrap.appendChild(pre);
    wrap.appendChild(run);
    msgsEl.appendChild(wrap);
    msgsEl.scrollTop = msgsEl.scrollHeight;
  }
}
// init
ping();
loadModels();
</script>
</body>
</html>
