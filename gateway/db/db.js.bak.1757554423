import path from 'path';
import { fileURLToPath } from "url";

import fs from 'fs';
import Database from 'better-sqlite3';

const isTest = process.env.NODE_ENV === 'test';

let db;
const DB_PATH = isTest ? ':memory:' : path.resolve(process.cwd(), 'gateway', 'db', 'app.db');
const MIGRATIONS_DIR = path.resolve(process.cwd(), 'gateway', 'db', 'migrations');
fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });

// Open database
if (isTest) {
  db = new Database(DB_PATH, { verbose: console.log });
} else {
  db = new Database(DB_PATH, { verbose: console.log });
}

// Run migrations
const migrationFiles = fs
  .readdirSync(MIGRATIONS_DIR)
  .filter((f) => f.endsWith('.sql'))
  .sort();
for (const file of migrationFiles) {
  const sql = fs.readFileSync(path.join(MIGRATIONS_DIR, file), 'utf8');
  db.exec(sql);
}

function run(sql, params = []) {
  try {
    const stmt = db.prepare(sql);
    const info = stmt.run(params);
    return info;
  } catch (err) {
    throw err;
  }
}
function get(sql, params = []) {
  try {
    const stmt = db.prepare(sql);
    const row = stmt.get(params);
    return row;
  } catch (err) {
    throw err;
  }
}

export function getUserByUsername(username) {
  const row = get('SELECT * FROM users WHERE username = ?', [username]);
  return row;
}
export function createUser(username, passwordHash) {
  const info = run('INSERT INTO users (username, password_hash) VALUES (?, ?)', [username, passwordHash]);
  return { id: info.lastInsertRowid, username };
}
export function setShortTerm(userId, workspaceId, content) {
  run(
    `INSERT INTO short_term_memory (user_id, workspace_id, content) VALUES (?, ?, ?)
ON CONFLICT(user_id, workspace_id) DO UPDATE SET content = excluded.content, updated_at = CURRENT_TIMESTAMP`,
    [userId, workspaceId, content]
  );
}
export function getShortTerm(userId, workspaceId) {
  const row = get('SELECT content FROM short_term_memory WHERE user_id = ? AND workspace_id = ?', [userId, workspaceId]);
  return row ? row.content : '';
}
export function setLongTerm(userId, workspaceId, content) {
  run(
    `INSERT INTO long_term_memory (user_id, workspace_id, content) VALUES (?, ?, ?)
ON CONFLICT(user_id, workspace_id) DO UPDATE SET content = excluded.content, updated_at = CURRENT_TIMESTAMP`,
    [userId, workspaceId, content]
  );
}
export function getLongTerm(userId, workspaceId) {
  const row = get('SELECT content FROM long_term_memory WHERE user_id = ? AND workspace_id = ?', [userId, workspaceId]);
  return row ? row.content : '';
}

export default {
  getUserByUsername,
  createUser,
  setShortTerm,
  getShortTerm,
  setLongTerm,
  getLongTerm,
};
